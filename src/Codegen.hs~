{-# LANGUAGE OverloadedStrings #-}

-- | Codegen.hs
-- A complete translator from a TALM dataflow graph in DOT format into TALM assembly.
module Codegen where

import           Data.Text.Lazy       (Text)
import qualified Data.Text.Lazy       as T
import qualified Data.Text.Lazy.IO    as TLIO
import           System.IO            (getContents)
import           Text.Regex.TDFA      ((=~))
import           Data.List            (partition)

-- | A node with its identifier and label
type Node = (Text, Text)

-- | An edge from -> to
type Edge = (Text, Text)

-- | Program entry: read DOT from stdin, write TALM assembly to stdout
main :: IO ()
main = do
  dot   <- TLIO.getContents
  let nodes  = parseNodes dot
      edges  = parseEdges dot
      instrs = generateInstructions nodes edges
  mapM_ TLIO.putStrLn instrs

-- | Parse node lines: e.g.,  n [label="const:1"];
parseNodes :: Text -> [Node]
parseNodes input =
  [ (name, label)
  | line <- T.lines input
  , let m = line =~ nodeRgx :: (String, String, String, [String])
  , not (null (snd4 m))
  , let [n,l] = snd4 m
  , let name  = T.pack n
  , let label = T.pack l
  ]
  where
    nodeRgx = "^ *([^ ]+) *\\[label=\\\"(.+)\\\"\"*]"
    snd4 (_,_,_,x) = x

-- | Parse edge lines: e.g.,  a -> b;
parseEdges :: Text -> [Edge]
parseEdges input =
  [ (src,dst)
  | line <- T.lines input
  , let m = line =~ edgeRgx :: (String,String,String,[String])
  , not (null (snd4 m))
  , let [s,d] = snd4 m
  , let src = T.pack s
  , let dst = T.pack d
  ]
  where
    edgeRgx = "^ *([^ ]+) *-> *([^ ;]+)"
    snd4 (_,_,_,x) = x

-- | Generate TALM instructions for all nodes in topological-ish order
generateInstructions :: [Node] -> [Edge] -> [Text]
generateInstructions nodes edges =
  map (genNode edges) nodes

-- | For a single node, collect its inputs and produce the TALM line
genNode :: [Edge] -> Node -> Text
genNode edges (name,label) =
  let ins    = [ src | (src,dst) <- edges, dst == name ]
      outs   = [ dst | (src,dst) <- edges, src == name ]
      opcode = labelToOpcode label
      imm    = labelToImmediate label
      nRes   = labelToResults label outs
      nSrc   = length ins
      dsts   = T.intercalate "," (if nRes==0 then [] else take nRes outs)
      srcs   = T.intercalate "," ins
      immTxt = maybe "" (" " <>) imm
  in T.concat [ opcode
              , " " , T.pack (show nRes)
              , " " , T.pack (show nSrc)
              , immTxt
              , " : " , dsts
              , if nSrc>0 then " <- " <> srcs else ""
              ]

-- | Map label to TALM opcode
labelToOpcode :: Text -> Text
labelToOpcode lab
  | "const:"   `T.isPrefixOf` lab = "const"
  | lab == "add"                 = "add"
  | lab == "sub"                 = "sub"
  | lab == "mul"                 = "mul"
  | lab == "div"                 = "div"
  | lab == "split"               = "split"
  | lab == "merge"               = "merge"
  | lab == "steer"               = "steer"
  | lab == "callgroup"           = "callgroup"
  | lab == "callsnd"             = "callsnd"
  | lab == "retsnd"              = "retsnd"
  | lab == "ret"                 = "ret"
  | lab == "inctag"              = "inctag"
  | lab == "tagop"               = "tagop"
  | lab == "and"                 = "and"
  | lab == "or"                  = "or"
  | lab == "xor"                 = "xor"
  | lab == "not"                 = "not"
  | lab == "eq"                  = "eq"
  | lab == "neq"                 = "neq"
  | lab == "lt"                  = "lt"
  | lab == "leq"                 = "leq"
  | lab == "gt"                  = "gt"
  | lab == "geq"                 = "geq"
  | lab == "super"               = "super"
  | lab == "specsuper"           = "specsuper"
  | lab == "superinstmacro"      = "superinstmacro"
  | "addi:"      `T.isPrefixOf` lab = "addi"
  | "subi:"      `T.isPrefixOf` lab = "subi"
  | "muli:"      `T.isPrefixOf` lab = "muli"
  | "divi:"      `T.isPrefixOf` lab = "divi"
  | otherwise                      = error $ "Unknown label: " ++ T.unpack lab

-- | Extract immediate operand, from labels like "const:5" or "addi:10"
labelToImmediate :: Text -> Maybe Text
labelToImmediate lab
  | ":" `T.isInfixOf` lab = Just (T.drop (T.findIndex (T.isInfixOf ":") lab `orElse` 0 + 1) lab)
  | otherwise              = Nothing
  where orElse (Just x) _ = x; orElse Nothing y = y

-- | Determine number of results, based on opcode and outgoing edges
labelToResults :: Text -> [Text] -> Int
labelToResults lab outs
  | "split"   == lab = length outs
  | "steer"   == lab = 2
  | "callgroup" == lab = 0
  | "callsnd"   == lab = 0
  | "retsnd"    == lab = 0
  | "ret"       == lab = 0
  | "inctag"    == lab = 0
  | "tagop"     == lab = 1
  | lab `elem` ["merge","add","sub","mul","div","and","or","xor","not",
                "eq","neq","lt","leq","gt","geq",
                "const","addi","subi","muli","divi",
                "super","specsuper","superinstmacro"] = 1
  | otherwise = error $ "Cannot determine results for label: " ++ T.unpack lab
